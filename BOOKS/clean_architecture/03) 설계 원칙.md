# SOLID 원칙
 <b>SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명한다.</b> 좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작된다. 좋은 벽돌을 사용하지 않으면 빌딩의 아키텍처가 좋고 나쁨은 그리 의미가 없다. 그래서 좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 필요한데, 그것이 바로 SOLID다.
 
* SRP: 단일 책임 원칙으로 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
* OCP: 개방-폐쇄 원칙으로 기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야한다.
* LSP: 리스코프 치환 원칙으로 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 지켜야한다.
* ISP: 인터페이스 분리 원칙으로 사용하지 않는 것에 의존하지 않아야한다.
* DIP: 의존성 역전 원칙으로 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.

## SRP (단일책임원칙)
 ```하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.```
 
 * 모듈? 단순한 정의는 소스파일을 의미한다. 하지만 일부 언어와 개발 환경에서는 코드를 소스파일에 저장하지 않고 모듈을 단순히 함수와 데이터 구조로 구성된 응집된 집합을 말한다.
 * 액터? 역할 수행자

### SRP 위반 예시

<img width="383" alt="스크린샷 2021-04-25 오전 10 43 22" src="https://user-images.githubusercontent.com/13283116/115977437-31e8c700-a5b3-11eb-8f7b-58c241c80c3b.png">

* 서로 다른 액터가 호출하는데, 메서드끼리 같은 로직을 호출한다고 가정했을 때 A그룹이 수정을 해보러면? B그룹도 영향을 받는다!

### 해결책
 서로 다른 액터가 호출하는 메서드를 각기 다른 클래스로 이동시켜야한다.
 
 <img width="563" alt="스크린샷 2021-04-25 오전 10 55 57" src="https://user-images.githubusercontent.com/13283116/115977677-036beb80-a5b5-11eb-83c9-d7a6ff0face3.png">

* 이런 상황에 흔히 쓰는 기법은 facade 디자인 패턴이다.
* EmployeeData 클래스는 아무런 메시지가 없는 구조체이며, 세 개의 클래스가 공유하도록 한다.
* 중요한 업무 규칙과 데이터를 가깝게 배치하는 것을 선호한다면, EmployeeData를 제거하고 Employee 클래스에 넣는다.

### SRP 결론
 SRP는 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다.
 
* 컴포넌트 수준: 공통 페쇄 원칙(CCP)
* 아키텍쳐 수준: 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축

## OCP (개방-폐쇄 원칙)
 ```소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야한다.```
 
* 새로운 기능을 추가할때, 별도의 코드 수정 없이 코드 추가만으로 기능을 제공할 수 있어야한다.
    * DIP가 적용된 상태에서 가능하다.
* <b>고수준 업무규칙과 저수준 세부내역을 구분하고, 저수준 세부내역이 고수준 업무규칙에 의존하도록 해야한다. 그래야 변경에 대한 수정이 쉽다.</b>

## LSP (리스코프 치환 원칙)
 상속/구현 관계일 때 부모와 자식 객체가 서로 치환 가능해야한다.
 
* 상속 사용 가이드 원칙?
* 아키텍쳐 관점에서 ```택시 파견 서비스 애플리케이션``` 예시
   * 같은 행위를 모두 A 형식으로 처리하던 것(부모)을 새로운 B 방식(자식)으로 처리해야하는 경우가 있다. 이 경우 기존 A 형식(부모)을 유지하려면 분기를 타거나 많은 코드가 추가된다.

### LSP 위반 예시
 정사각형/직사각형 문제
 
* ```Rectangle``` 부모 클래스와 ```Square``` 자식 클래스의 ```getWidth()``` 메서드는 서로 치환되지 않는다.
* ```Square``` 클래스만 예외로 두어야 하는가? 이를 처리하는 코드에서 정사각형인지 판단해야하므로 매번 분기가 필요하다.

## ISP (인터페이스 분리 원칙)
 아키텍쳐 관점에서 인터페이스 분리를 제대로 하지 않으면, 불필요한 코드도 재 컴파일되고 배포를 새로 해야할 수 있다.

* 배포 의존성, 재컴파일
* 프로그래밍 언어에 연관이 있다.
* 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠질 수 있다.

## DIP (의존성 역전 원칙)
 의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
 
 인터페이스를 변경하지 않고도 구현체에 기능을 추가 하기 위한 방법을 제공한다. (OCP)
 
* 변동성이 큰 구체 클래스를 참조하지 말라
* 변동성이 큰 구체 클래스로부터 파생하지 말라
* 구체 함수를 오버라이드 하지 말라
* 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라

<img width="501" alt="스크린샷 2021-04-25 오전 11 38 13" src="https://user-images.githubusercontent.com/13283116/115978500-c0147b80-a5ba-11eb-9273-5ae846bf0355.png">

* 위 아키텍쳐 경계는 두 가지 컴포넌트를 분리한다. 하나는 추상 컴포넌트이고, 다른 하나는 구체 컴포넌트이다.
  * 추상 컴포넌트는 모든 고수준 업무 규칙을 포함한다.
  * 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.
* 제어흐름은 소스 코드 의존성과 정반대 방향으로 곡선을 가로지른다.
  * 다시 말해 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. <- 이러한 이유로 이 원칙을 ```의존성 역전```이라 부른다.
* 물론 DIP 위배를 모두 없앨 수는 없다. 대표적인 구체 클래스가 ```main``` 함수다. 
* 의존성은 위 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향해야하며, 이 규칙을 ```의존성 규칙``` 이라 부른다.
